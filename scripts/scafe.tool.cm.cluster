#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                   ---> scafe.tool.cm.cluster <---
                          <--- tool, common mode, cluster ctss --->

 Description:
   This tool generate TSS cluster from a ctss bed file, using an external tool paraclu with user-defined cutoffs

 Usage:
   scafe.tool.cm.cluster [options] --cluster_ctss_bed_path --outputPrefix --outDir
   
   --cluster_ctss_bed_path       <required> [string]  ctss file used for clustering,
                                                      "collapse" ctss file from scafe.tool.sc.bam_to_ctss.pl, 
                                                      4th column is number of cells and 5th column is number UMI
   --outputPrefix                <required> [string]  prefix for the output files
   --outDir                      <required> [string]  directory for the output files
   --count_ctss_bed_path_list    (optional) [string]  comma delimited list of ctss bed file, 
                                                      using for filtering of clusters based signal 
                                                      (default=$cluster_ctss_bed_path) 
   --count_scope_bed_path        (optional) [string]  a bed file specify the scope for counting in $count_ctss_bed_path_list, 
                                                      using for filtering of clusters based signal
                                                      (default=$cluster_ctss_bed_path) 
   --min_pos_count               (optional) [integer] minimum counts per position, used for filtering the raw signal 
                                                      in $cluster_ctss_bed_path before clustering (default = 1)
   --min_cluster_cpm             (optional) [float]   minimum counts per million (cpm) for a cluster (default = 1e-5)
   --min_summit_count            (optional) [integer] minimum counts at the summit of a cluster (default = 3)
   --min_cluster_count           (optional) [integer] minimum counts within a cluster (default = 5)
   --min_num_sample_expr_cluster (optional) [integer] minimum number of samples (or cells) detected at the 
                                                      summit of a cluster (default = 3)
   --min_num_sample_expr_summit  (optional) [integer] minimum number of samples (or cells) detected within 
                                                      of a cluster (default = 5)
   --merge_dist                  (optional) [integer] maximum distance for merging closely located clusters, 
                                                      -1 to turn off merging (default = -1)
   --overwrite                   (optional) [yes/no]  erase outDir/outputPrefix before running (default=no)

 Dependencies:
   paraclu
   paraclu-cut.sh
   bedtools

 For demo, cd to SCAFE dir and run,
   scafe.tool.cm.cluster \
   --overwrite=yes \
   --cluster_ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.collapse.ctss.bed.gz \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/cluster/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0 [June 6, 2022]
	-parallelized part of the processes

=cut#
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->1090
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->301
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($cluster_ctss_bed_path, $count_ctss_bed_path_list, $count_scope_bed_path, $min_cluster_cpm, $min_cluster_count, $min_pos_count, $min_summit_count, $merge_dist, $min_num_sample_expr_cluster, $min_num_sample_expr_summit, $outputPrefix, $outDir, $overwrite) = &readParameters();#->901
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$outputPrefix";
my $force_rerun = 'yes'; #---[2020/04/21 0:18] force to rerun paraclu even results exists

my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $resultParacluDir = "$result_dir/paraclu/"; push @mkDirAry, $resultParacluDir;
my $resultBedDir = "$result_dir/bed/"; push @mkDirAry, $resultBedDir;
my $resultPreMergeBedDir = "$result_dir/bed/pre_merge/"; push @mkDirAry, $resultPreMergeBedDir;
my $resultLogDir = "$result_dir/log/"; push @mkDirAry, $resultLogDir;
my $resultScriptDir = "$result_dir/script/"; push @mkDirAry, $resultScriptDir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&printStartOrFinishMessage("startMessage");#->867
&logCalledCMDAndScript($ARGVStr, $resultScriptDir, $scriptAbsPath);#->472
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_ReadInfoAndRun
#
#<section ID="ReadInfoAndRun" num="2">
my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();#->201
my ($count_ctss_bed_hsh_ref) = &getCountCtssPath($count_ctss_bed_path_list, $count_scope_bed_path);#->319
my ($paraclu_input_path, $min_cluster_count_by_cpm) = &parseParacluInput($cluster_ctss_bed_path, $min_pos_count, $min_cluster_cpm, $resultParacluDir);#->584
my ($paraclu_bed_path) = &runParaclu($paraclu_input_path, $paraclu_bin, $cut_sh_path, $resultParacluDir, $resultPreMergeBedDir, $min_cluster_count, $min_cluster_count_by_cpm, $paramTag, $force_rerun);#->984
my ($paraclu_cluster_info_hsh_ref, $summit_bed_path) = &getTssClusterSummit($resultPreMergeBedDir, $paraclu_bed_path, $cluster_ctss_bed_path, $bedtools_bin, $paramTag);#->423
my ($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref) = &mergeParacluClusters($bedtools_bin, $summit_bed_path, $merge_dist, $cluster_ctss_bed_path, $resultBedDir, $resultLogDir, $paramTag, $paraclu_cluster_info_hsh_ref, $min_summit_count);#->497
&getNumSampleExpressed($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref, $count_ctss_bed_hsh_ref, $bedtools_bin);#->364
&printFinalBedAndLog($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref, $resultBedDir, $resultLogDir, $paramTag, $min_num_sample_expr_cluster, $min_num_sample_expr_summit);#->641
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_finishingTasks
#
#<section ID="finishingTasks" num="3">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->752
&printStartOrFinishMessage("finishMessage");#->867
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=5]:
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=8]:
#		checkAllExecutable, getCountCtssPath, getNumSampleExpressed
#		getTssClusterSummit, mergeParacluClusters, parseParacluInput
#		printFinalBedAndLog, runParaclu
#
#====================================================================================================================================================#

sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|962
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bgzip_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin, $tabix_bin
#	toCall: my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 153
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $tabix_bin = "$dirPath/../resources/bin/tabix/tabix";
	my $bgzip_bin = "$dirPath/../resources/bin/bgzip/bgzip";
	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->962
	
	{
		my $stdOut = `$tabix_bin  --version 2>&1`;
		if ($stdOut =~ m/tabix \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: tabix version: $1", 0, "\n");#->962
		} else {
			die "tabix is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bgzip_bin --version 2>&1`;
		if ($stdOut =~ m/bgzip \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: bgzip version: $1", 0, "\n");#->962
		} else {
			die "bgzip is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->962
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->962
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->962
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->962
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->962
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->962
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|867, reportAndLogStatus|962
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 1_defineHardCodedParam|127, 3_finishingTasks|165
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 108, 883, 887, 892, 896, 978, 979
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub getCountCtssPath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|962
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $count_ctss_bed_path_list, $count_scope_bed_path
#	output: $count_ctss_bed_hsh_ref
#	toCall: my ($count_ctss_bed_hsh_ref) = &getCountCtssPath($count_ctss_bed_path_list, $count_scope_bed_path);
#	calledInLine: 154
#....................................................................................................................................................#
	my ($count_ctss_bed_path_list, $count_scope_bed_path) = @_;
	
	&reportAndLogStatus("checking count_ctss_bed_path_list", 10, "\n");#->962
	
	my $count_ctss_bed_hsh_ref = {};
	if (defined $count_ctss_bed_path_list) {
		foreach my $count_ctss_bed_path (split /\,/, $count_ctss_bed_path_list) {
			if (-s $count_ctss_bed_path) {
				if (exists $count_ctss_bed_hsh_ref->{$count_ctss_bed_path}) {
					&reportAndLogStatus("WARNING: $count_ctss_bed_path appeared more than once.", 10, "\n");#->962
				}
				$count_ctss_bed_hsh_ref->{'count_ctss_bed_path'}{$count_ctss_bed_path}++;
			} else {
				die "count_ctss_bed_path: $count_ctss_bed_path does not exist\n";
			}
		}

		my $num_ctss_count_bed = keys %{$count_ctss_bed_hsh_ref->{'count_ctss_bed_path'}};
		&reportAndLogStatus("stored $num_ctss_count_bed ctss bed for counting num sample expressed", 10, "\n");#->962
	} else {
		&reportAndLogStatus("num sample expressed will not be used for filtering", 10, "\n");#->962
	}

	if (defined $count_scope_bed_path) {
		if (-s $count_scope_bed_path) {
			$count_ctss_bed_hsh_ref->{'count_scope_bed_path'} = $count_scope_bed_path;
		} else {
			die "count_scope_bed_path: $count_scope_bed_path does not exist\n";
		}
	}
	
	return ($count_ctss_bed_hsh_ref);
}
sub getNumSampleExpressed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|962
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $count_ctss_bed_hsh_ref, $tmp_merge_bed_file_path, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &getNumSampleExpressed($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref, $count_ctss_bed_hsh_ref, $bedtools_bin);
#	calledInLine: 159
#....................................................................................................................................................#
	my ($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref, $count_ctss_bed_hsh_ref, $bedtools_bin) = @_;
	
	if (exists $count_ctss_bed_hsh_ref->{'count_ctss_bed_path'}) {
		foreach my $count_ctss_bed_path (keys %{$count_ctss_bed_hsh_ref->{'count_ctss_bed_path'}}) {
			my ($fileName, $fileDir, $fileSuffix) = fileparse($count_ctss_bed_path, qr/\.[^.]*/);
			&reportAndLogStatus("counting num sample expressed in $fileName$fileSuffix", 10, "\n");#->962

			my $bedtools_cmd;
			if (exists $count_ctss_bed_hsh_ref->{'count_scope_bed_path'}) {
				&reportAndLogStatus("couting within scope of count_scope_bed_path", 10, "\n");#->962
				my $count_scope_bed_path = $count_ctss_bed_hsh_ref->{'count_scope_bed_path'};
				$bedtools_cmd = "$bedtools_bin intersect -sorted -s -wa -a $count_ctss_bed_path -b $count_scope_bed_path | $bedtools_bin intersect -sorted -s -wo -a $tmp_merge_bed_file_path -b stdin";
				
			} else {
				$bedtools_cmd = "$bedtools_bin intersect -sorted -s -wo -a $tmp_merge_bed_file_path -b $count_ctss_bed_path";

			}
			#print "$bedtools_cmd\n";
			open BEDTOOLS, "$bedtools_cmd | cut -f 4,8,15,16,17 |";
			while (<BEDTOOLS>) {
				#print $_;	
				chomp;
				#chr1	7973224	7973330	chr1_7973224_7973330_-	1727	-	7973316	7973317	31,120,180	1	106	0	chr1	7973279	7973280	11	11	-	1
				#chr1	7973224	7973330	chr1_7973224_7973330_-	1727	-	7973316	7973317	31,120,180	1	106	0	chr1	7973280	7973281	1	1	-	1
				#chr1	7973224	7973330	chr1_7973224_7973330_-	1727	-	7973316	7973317	31,120,180	1	106	0	chr1	7973281	7973282	137	168	-	1
				my ($tssClusterID, $summit_pos, $ctss_pos, $num_sample_expr) = split /\t/;
				if (exists $tssCluster_info_hsh_ref->{$tssClusterID}) {
					$tssCluster_info_hsh_ref->{$tssClusterID}{'num_sample_expr_cluster'} += $num_sample_expr;
					if ($summit_pos == $ctss_pos) {
						$tssCluster_info_hsh_ref->{$tssClusterID}{'num_sample_expr_summit'} += $num_sample_expr;
					}
				} else {
					die "tssClusterID $tssClusterID does not exists in $tssCluster_info_hsh_ref\n";
				}
			}
			close BEDTOOLS;
		}
	} else {
		&reportAndLogStatus("No count_ctss_bed_path. Assigning num_sample_expr_cluster -1 to all tssClusters", 10, "\n");#->962
		foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{'num_sample_expr_cluster'} = -1;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'num_sample_expr_summit'} = -1;
		}
	}

	return ();
}
sub getTssClusterSummit {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|962
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $cluster_ctss_bed_path, $paraclu_bed_path, $paramTag, $resultPreMergeBedDir
#	output: $paraclu_cluster_info_hsh_ref, $summit_bed_path
#	toCall: my ($paraclu_cluster_info_hsh_ref, $summit_bed_path) = &getTssClusterSummit($resultPreMergeBedDir, $paraclu_bed_path, $cluster_ctss_bed_path, $bedtools_bin, $paramTag);
#	calledInLine: 157
#....................................................................................................................................................#
	my ($resultPreMergeBedDir, $paraclu_bed_path, $cluster_ctss_bed_path, $bedtools_bin, $paramTag) = @_;
	
	my $paraclu_cluster_info_hsh_ref = {};

	&reportAndLogStatus("getting summit position", 10, "\n");#->962
	my $bedtools_cmd = "$bedtools_bin intersect -sorted -a $paraclu_bed_path -b $cluster_ctss_bed_path -s -wao";
	open BEDTOOLS, "$bedtools_cmd |";
	while (<BEDTOOLS>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $paraclu_clusterID, $stability, $strand, undef, undef, $ctss_pos, undef, $ctss_read) = split /\t/;
		if (not exists $paraclu_cluster_info_hsh_ref->{$paraclu_clusterID}) {
			$paraclu_cluster_info_hsh_ref->{$paraclu_clusterID} = [$chrom, $chromStart, $chromEnd, $strand, $ctss_read, $ctss_pos, $ctss_read, $stability];
		} else {
			$paraclu_cluster_info_hsh_ref->{$paraclu_clusterID}[-4] += $ctss_read;

			if ($ctss_read > $paraclu_cluster_info_hsh_ref->{$paraclu_clusterID}[-2]) {
				$paraclu_cluster_info_hsh_ref->{$paraclu_clusterID}[-2] = $ctss_read;
				$paraclu_cluster_info_hsh_ref->{$paraclu_clusterID}[-3] = $ctss_pos;
			}
		}
	}
	close BEDTOOLS;
	my $summit_bed_path = "$resultPreMergeBedDir/$paramTag.pre_merge.tssCluster.summit.bed.gz";
	$globalReadmeHsh_ref->{$summit_bed_path}{'description'} = "bed file of parsed paraclu cluster summit after 'cutting'";

	&reportAndLogStatus("printing paraclu summit bed", 10, "\n");#->962
	open SUMMIT, "| sort -k1,1 -k2,2n | gzip -c >$summit_bed_path";
	foreach my $paraclu_clusterID (keys %{$paraclu_cluster_info_hsh_ref}) {
		my ($chrom, undef, undef, $strand, $num_read, $summit_pos, $summit_read, $stability) = @{$paraclu_cluster_info_hsh_ref->{$paraclu_clusterID}};
		my $chromStart = $summit_pos-1;
		my $chromEnd = $summit_pos;
		print SUMMIT join "", (join "\t", ($chrom, $chromStart, $chromEnd, $paraclu_clusterID, $summit_read, $strand)), "\n";
	}
	close SUMMIT;
	
	return ($paraclu_cluster_info_hsh_ref, $summit_bed_path);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_defineHardCodedParam|127
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $resultScriptDir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $resultScriptDir, $scriptAbsPath);
#	calledInLine: 145
#....................................................................................................................................................#
	my ($ARGVStr, $resultScriptDir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$resultScriptDir/script.ran.pl";
	my $calledCMDPath = "$resultScriptDir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub mergeParacluClusters {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|962
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $cluster_ctss_bed_path, $merge_dist, $min_summit_count, $paraclu_cluster_info_hsh_ref, $paramTag, $resultBedDir, $resultLogDir, $summit_bed_path
#	output: $tmp_merge_bed_file_path, $tssCluster_info_hsh_ref
#	toCall: my ($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref) = &mergeParacluClusters($bedtools_bin, $summit_bed_path, $merge_dist, $cluster_ctss_bed_path, $resultBedDir, $resultLogDir, $paramTag, $paraclu_cluster_info_hsh_ref, $min_summit_count);
#	calledInLine: 158
#....................................................................................................................................................#
	my ($bedtools_bin, $summit_bed_path, $merge_dist, $cluster_ctss_bed_path, $resultBedDir, $resultLogDir, $paramTag, $paraclu_cluster_info_hsh_ref, $min_summit_count) = @_;

	&reportAndLogStatus("merging distance = $merge_dist", 10, "\n");#->962
	&reportAndLogStatus("minimum post-merge summit count = $min_summit_count", 10, "\n");#->962
	&reportAndLogStatus("start merging clusters", 10, "\n");#->962

	&reportAndLogStatus("merging at $merge_dist nt", 10, "\n");#->962
	my $tmp_merge_dir = "$resultBedDir/tmp_merged/";
	system ("mkdir -pm 755 $tmp_merge_dir");
	my $tmp_merge_bed_file_path = "$tmp_merge_dir/$paramTag.tssCluster.tmp_merged.bed.gz";
	open OUTBED, "| sort -k1,1 -k2,2n | gzip -c >$tmp_merge_bed_file_path";

	$globalReadmeHsh_ref->{$tmp_merge_bed_file_path}{'description'} = "bed file of the final tssCluster (post merging and filtering by summit count). Score column refers to number of read";

	my $tssCluster_info_hsh_ref = {};
	
	open BEDTOOLS, "$bedtools_bin merge -i $summit_bed_path -s -d $merge_dist -c 4 -o distinct | cut -f 4 |";
	while (<BEDTOOLS>) {
		chomp;
		my ($paraclu_clusterID_str) = $_;
		my $merged_cluster_info_hsh_ref = {};
		my $num_read = 0;
		foreach my $paraclu_clusterID (split /,/) {
			die "paraclu_clusterID $paraclu_clusterID does not exists\n" if not exists $paraclu_cluster_info_hsh_ref->{$paraclu_clusterID};
			my ($indiv_chrom, $indiv_chromStart, $indiv_chromEnd, $indiv_strand, $indiv_num_read, $indiv_summit_pos, $indiv_summit_read, $indiv_stability) = @{$paraclu_cluster_info_hsh_ref->{$paraclu_clusterID}};
			push @{$merged_cluster_info_hsh_ref->{'bound'}}, ($indiv_chromStart, $indiv_chromEnd);
			push @{$merged_cluster_info_hsh_ref->{'stability'}}, $indiv_stability;
			$merged_cluster_info_hsh_ref->{'chrom'} = $indiv_chrom;
			$merged_cluster_info_hsh_ref->{'strand'} = $indiv_strand;
			$merged_cluster_info_hsh_ref->{'summit'}{$indiv_summit_read} = $indiv_summit_pos;
			$num_read += $indiv_num_read;
		}

		@{$merged_cluster_info_hsh_ref->{'bound'}} = sort {$a<=>$b} @{$merged_cluster_info_hsh_ref->{'bound'}};
		my $stability = sum(@{$merged_cluster_info_hsh_ref->{'stability'}})/@{$merged_cluster_info_hsh_ref->{'stability'}};
		$stability = sprintf "%.5f", $stability;
		my @summit_read_ary = sort {$a<=>$b} (keys %{$merged_cluster_info_hsh_ref->{'summit'}});
		my $summit_read = $summit_read_ary[-1];
		my $summit_pos = $merged_cluster_info_hsh_ref->{'summit'}{$summit_read};
		
		if ($summit_read >= $min_summit_count) {
							
			my $num_paraclu_cluster = keys %{$merged_cluster_info_hsh_ref->{'summit'}};
			my $chrom = $merged_cluster_info_hsh_ref->{'chrom'};
			my $chromStart = $merged_cluster_info_hsh_ref->{'bound'}[0];
			my $chromEnd = $merged_cluster_info_hsh_ref->{'bound'}[-1];
			my $strand = $merged_cluster_info_hsh_ref->{'strand'};
		
			my $tssClusterID = join "_", ($chrom, $chromStart, $chromEnd, $strand);
			my $size = $chromEnd - $chromStart;
			
			my $thickStart = $summit_pos - 1;
			my $thickEnd = $summit_pos;
			my $itemRgb = "227,26,28";
			$itemRgb = "31,120,180" if $strand eq '-';
			my $blockCount = 1;
			my $blockSizes = $size;
			my $blockStarts = 0;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'} = $chrom;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'num_paraclu_cluster'} = $num_paraclu_cluster;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'size'} = $size;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'stability'} = $stability;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'num_read'} = $num_read;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'summit_pos'} = $summit_pos;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'summit_read'} = $summit_read;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'num_sample_expr_cluster'} = 0;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'num_sample_expr_summit'} = 0;
			print OUTBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $tssClusterID, $num_read, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		}
	}
	close BEDTOOLS;
	close OUTBED;

	return ($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref);
}
sub parseParacluInput {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|962
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $cluster_ctss_bed_path, $min_cluster_cpm, $min_pos_count, $resultParacluDir
#	output: $min_cluster_count_by_cpm, $paraclu_input_path
#	toCall: my ($paraclu_input_path, $min_cluster_count_by_cpm) = &parseParacluInput($cluster_ctss_bed_path, $min_pos_count, $min_cluster_cpm, $resultParacluDir);
#	calledInLine: 155
#....................................................................................................................................................#
	my ($cluster_ctss_bed_path, $min_pos_count, $min_cluster_cpm, $resultParacluDir) = @_;
	
	my %itemForThrHsh = ();
	my $threadID = 1;
	
	my $paraclu_input_path = "$resultParacluDir/paraclu.input.txt.gz";
	$globalReadmeHsh_ref->{$paraclu_input_path}{'description'} = "Input for paraclu";

	my $total_count = 0;
	
	&reportAndLogStatus("Parsing paraclu input with min_pos_count = $min_pos_count", 10, "\n");#->962
	&reportAndLogStatus("Position with counts < $min_pos_count will be removed", 10, "\n");#->962

	open PARACLUINPUT, "| gzip -c >$paraclu_input_path";
	if ($cluster_ctss_bed_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $cluster_ctss_bed_path|");
	} else {
		open (FILEIN, "<", $cluster_ctss_bed_path);
	}

	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my @bedAry = split /\t/;
		my $chrom = $bedAry[0];
		my $pos = $bedAry[2];
		my $score = $bedAry[4];
		my $strand = $bedAry[5];
		
		$total_count += $score;
		if ($score >= $min_pos_count) {
			print PARACLUINPUT join "", (join "\t", ($chrom, $strand, $pos, $score)), "\n";
		}
	}
	close FILEIN;
	close PARACLUINPUT;

	my $total_count_millions = sprintf "%.5f", $total_count/1000000;
	my $min_cluster_count_by_cpm = sprintf "%.0f", $min_cluster_cpm*$total_count_millions;

	&reportAndLogStatus("total_count = $total_count_millions millions", 10, "\n");#->962
	&reportAndLogStatus("min_cluster_cpm = $min_cluster_cpm", 10, "\n");#->962

	return ($paraclu_input_path, $min_cluster_count_by_cpm);
}
sub printFinalBedAndLog {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|962
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $min_num_sample_expr_cluster, $min_num_sample_expr_summit, $paramTag, $resultBedDir, $resultLogDir, $tmp_merge_bed_file_path, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &printFinalBedAndLog($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref, $resultBedDir, $resultLogDir, $paramTag, $min_num_sample_expr_cluster, $min_num_sample_expr_summit);
#	calledInLine: 160
#....................................................................................................................................................#
	my ($tmp_merge_bed_file_path, $tssCluster_info_hsh_ref, $resultBedDir, $resultLogDir, $paramTag, $min_num_sample_expr_cluster, $min_num_sample_expr_summit) = @_;

	&reportAndLogStatus("printing final cluster bed and log", 10, "\n");#->962
	
	my $read_cut_ary_ref = [(1..15),30,40,50,60,70,80,90,100];
	my $size_cut_ary_ref = [5,10,15,20,25,35,40,45,50,60,70,80,90,100,125,150,175,200,300,400,500];
	
	my $interval_hsh_ref = {
		'cluster_read_less_than' => $read_cut_ary_ref,
		'summit_read_less_than' => $read_cut_ary_ref,
		'num_sample_expr_cluster_less_than' => $read_cut_ary_ref,
		'num_sample_expr_summit_less_than' => $read_cut_ary_ref,
		'size_greater_than' => $size_cut_ary_ref,
	},
	
	my $count_hsh_ref = {};
	foreach my $param (keys %{$interval_hsh_ref}) {
		foreach my $cutoff (@{$interval_hsh_ref->{$param}}) {
			$count_hsh_ref->{$param}{$cutoff} = 0;
		}
	};
	
	my $out_bed_file_path = "$resultBedDir/$paramTag.tssCluster.bed.gz";
	my $out_log_file_path = "$resultLogDir/$paramTag.tssCluster.log.tsv.gz";
	open OUTBED, "| gzip -c >$out_bed_file_path";
	open OUTLOG, "| gzip -c >$out_log_file_path";

	print OUTLOG join "", (join "\t", ('tssClusterID', 'chrom', 'num_paraclu_cluster', 'size', 'num_read', 'summit_pos', 'summit_read', 'num_sample_expr_cluster', 'num_sample_expr_summit', 'stability')), "\n";

	$globalReadmeHsh_ref->{$out_log_file_path}{'description'} = "information of the final tssCluster (post merging and filtering by summit count)";
	$globalReadmeHsh_ref->{$out_bed_file_path}{'description'} = "bed file of the final tssCluster (post merging and filtering by summit count and num sample expressed). Score column refers to number of read";
	
	if ($tmp_merge_bed_file_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $tmp_merge_bed_file_path|");
	} else {
		open (FILEIN, "<", $tmp_merge_bed_file_path);
	}
	
	my $total_num = 0;
	
	while (<FILEIN>) {
		chomp;
		my @splt = split /\t/;
		my $tssClusterID = $splt[3];
		
		die "tssClusterID $tssClusterID does not exists\n" if not exists $tssCluster_info_hsh_ref->{$tssClusterID};

		my $num_sample_expr_cluster = $tssCluster_info_hsh_ref->{$tssClusterID}{'num_sample_expr_cluster'};
		my $num_sample_expr_summit = $tssCluster_info_hsh_ref->{$tssClusterID}{'num_sample_expr_summit'};
		
		next if ($num_sample_expr_cluster != -1 and $num_sample_expr_cluster < $min_num_sample_expr_cluster);
		next if ($num_sample_expr_summit != -1 and $num_sample_expr_summit < $min_num_sample_expr_summit);

		$total_num++;
		my $chrom = $tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'};
		my $num_paraclu_cluster = $tssCluster_info_hsh_ref->{$tssClusterID}{'num_paraclu_cluster'};
		my $size = $tssCluster_info_hsh_ref->{$tssClusterID}{'size'};
		my $num_read = $tssCluster_info_hsh_ref->{$tssClusterID}{'num_read'};
		my $summit_pos = $tssCluster_info_hsh_ref->{$tssClusterID}{'summit_pos'};
		my $summit_read = $tssCluster_info_hsh_ref->{$tssClusterID}{'summit_read'};
		my $stability = $tssCluster_info_hsh_ref->{$tssClusterID}{'stability'};
		
		foreach my $param (keys %{$count_hsh_ref}) {
			foreach my $cutoff (keys %{$count_hsh_ref->{$param}}) {
				if ($param eq 'cluster_read_less_than') {
					$count_hsh_ref->{$param}{$cutoff}++ if $num_read < $cutoff;
				} elsif ($param eq 'summit_read_less_than') {
					$count_hsh_ref->{$param}{$cutoff}++ if $summit_read < $cutoff;
				} elsif ($param eq 'num_sample_expr_summit_less_than') {
					$count_hsh_ref->{$param}{$cutoff}++ if $num_sample_expr_summit < $cutoff;
				} elsif ($param eq 'num_sample_expr_cluster_less_than') {
					$count_hsh_ref->{$param}{$cutoff}++ if $num_sample_expr_cluster < $cutoff;
				} elsif ($param eq 'size_greater_than') {
					$count_hsh_ref->{$param}{$cutoff}++ if $size > $cutoff;
				} else {
					die;
				}
			
			}
		}
		
		print OUTLOG join "", (join "\t", ($tssClusterID, $chrom, $num_paraclu_cluster, $size, $num_read, $summit_pos, $summit_read, $num_sample_expr_cluster, $num_sample_expr_summit, $stability)), "\n";
		print OUTBED $_."\n";
	}
	close FILEIN;
	close OUTBED;
	close OUTLOG;
	
	&reportAndLogStatus("The final set contains $total_num clusters", 10, "\n");#->962
	foreach my $param (sort keys %{$count_hsh_ref}) {
		foreach my $cutoff (sort {$a <=> $b} keys %{$count_hsh_ref->{$param}}) {
			my $count = $count_hsh_ref->{$param}{$cutoff};
			my $pct = sprintf "%.2f", 100*$count/$total_num;
			&reportAndLogStatus("With $param $cutoff n=$count [$pct%]", 10, "\n");#->962
		}
	}

	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_finishingTasks|165
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 168
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort {$a cmp $b} keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			my $headerColLen = max(@colLenCountHsh)+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}

	my $fileDir_colLen = max(@{$filelistLenCountHsh{'dir'}})+2;
	my $fileName_colLen = max(@{$filelistLenCountHsh{'name'}})+2;
	my $fileDescription_colLen = max(@{$filelistLenCountHsh{'description'}})+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|301
#	appearInSub: >none
#	primaryAppearInSection: 1_defineHardCodedParam|127, 3_finishingTasks|165
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 144, 169
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->301
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->301
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->301
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->301
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|119
#	secondaryAppearInSection: >none
#	input: none
#	output: $cluster_ctss_bed_path, $count_ctss_bed_path_list, $count_scope_bed_path, $merge_dist, $min_cluster_count, $min_cluster_cpm, $min_num_sample_expr_cluster, $min_num_sample_expr_summit, $min_pos_count, $min_summit_count, $outDir, $outputPrefix, $overwrite
#	toCall: my ($cluster_ctss_bed_path, $count_ctss_bed_path_list, $count_scope_bed_path, $min_cluster_cpm, $min_cluster_count, $min_pos_count, $min_summit_count, $merge_dist, $min_num_sample_expr_cluster, $min_num_sample_expr_summit, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 122
#....................................................................................................................................................#
	
	my ($cluster_ctss_bed_path, $count_ctss_bed_path_list, $count_scope_bed_path, $min_cluster_cpm, $min_cluster_count, $min_pos_count, $min_summit_count, $merge_dist, $min_num_sample_expr_cluster, $min_num_sample_expr_summit, $outputPrefix, $outDir, $overwrite);

	$min_cluster_cpm = 1e-5;
	$min_pos_count = 1;
	$min_summit_count = 3;
	$min_num_sample_expr_cluster = 5;
	$min_num_sample_expr_summit = 3;
	$min_cluster_count = 5;
	$merge_dist = -1;
	$overwrite= 'no';

	GetOptions 	(
		"cluster_ctss_bed_path=s"			=>	\$cluster_ctss_bed_path,
		"count_ctss_bed_path_list:s"		=>	\$count_ctss_bed_path_list,
		"count_scope_bed_path:s"			=>	\$count_scope_bed_path,
		"min_pos_count=i"						=>	\$min_pos_count,
		"min_cluster_cpm=f"					=>	\$min_cluster_cpm,
		"min_summit_count=s"					=>	\$min_summit_count,
		"min_cluster_count=s"				=>	\$min_cluster_count,
		"min_num_sample_expr_cluster=i"	=>	\$min_num_sample_expr_cluster,
		"min_num_sample_expr_summit=i"	=>	\$min_num_sample_expr_summit,
		"merge_dist=i"							=>	\$merge_dist,
		"outputPrefix=s"						=>	\$outputPrefix,
		"outDir=s"								=>	\$outDir,
		"overwrite=s"							=>	\$overwrite,
		'help'									=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $cluster_ctss_bed_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'cluster_ctss_bed_path' => $cluster_ctss_bed_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	$count_ctss_bed_path_list = $cluster_ctss_bed_path if not defined $count_ctss_bed_path_list;
	$count_scope_bed_path = $cluster_ctss_bed_path if not defined $count_scope_bed_path;
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
		
	return($cluster_ctss_bed_path, $count_ctss_bed_path_list, $count_scope_bed_path, $min_cluster_cpm, $min_cluster_count, $min_pos_count, $min_summit_count, $merge_dist, $min_num_sample_expr_cluster, $min_num_sample_expr_summit, $outputPrefix, $outDir, $overwrite);
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|301
#	appearInSub: checkAllExecutable|201, getCountCtssPath|319, getNumSampleExpressed|364, getTssClusterSummit|423, mergeParacluClusters|497, parseParacluInput|584, printFinalBedAndLog|641, runParaclu|984
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_ReadInfoAndRun|150
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 224, 229, 238, 247, 256, 265, 274, 283, 292, 332, 339, 348, 350, 380, 384, 413, 438, 459, 510, 511, 512, 514, 605, 606, 635, 636, 654, 740, 745, 1003, 1004, 1005, 1022, 1026, 1055
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->301
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->301
	
	return ();
}
sub runParaclu {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|962
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $cut_sh_path, $force_rerun, $min_cluster_count, $min_cluster_count_by_cpm, $paraclu_bin, $paraclu_input_path, $paramTag, $resultParacluDir, $resultPreMergeBedDir
#	output: $paraclu_bed_path
#	toCall: my ($paraclu_bed_path) = &runParaclu($paraclu_input_path, $paraclu_bin, $cut_sh_path, $resultParacluDir, $resultPreMergeBedDir, $min_cluster_count, $min_cluster_count_by_cpm, $paramTag, $force_rerun);
#	calledInLine: 156
#....................................................................................................................................................#
	my ($paraclu_input_path, $paraclu_bin, $cut_sh_path, $resultParacluDir, $resultPreMergeBedDir, $min_cluster_count, $min_cluster_count_by_cpm, $paramTag, $force_rerun) = @_;
	
	my %itemForThrHsh = ();
	my $threadID = 1;
	
	my $min_paraclu_count = $min_cluster_count;
	$min_paraclu_count = $min_cluster_count_by_cpm if $min_cluster_count_by_cpm > $min_paraclu_count;
	
	&reportAndLogStatus("min_cluster_count_by_cpm = $min_cluster_count_by_cpm ", 10, "\n");#->962
	&reportAndLogStatus("min_cluster_count = $min_cluster_count", 10, "\n");#->962
	&reportAndLogStatus("min_paraclu_count = $min_paraclu_count", 10, "\n");#->962
		
	my $paraclu_sh_path = "$resultParacluDir/run_paraclu.sh";
	my $paraclu_uncut_path = "$resultParacluDir/paraclu.output.uncut.txt.gz";
	my $paraclu_cut_path = "$resultParacluDir/paraclu.output.cut.txt.gz";
	my $paraclu_bed_path = "$resultPreMergeBedDir/$paramTag.pre_merge.tssCluster.bed.gz";
	my $paraclu_rev_bed_path = "$resultPreMergeBedDir/$paramTag.pre_merge.tssCluster.rev.bed.gz";
	my $paraclu_fwd_bed_path = "$resultPreMergeBedDir/$paramTag.pre_merge.tssCluster.fwd.bed.gz";

	if	(	$force_rerun eq 'no' and 
			-s $paraclu_sh_path and 
			-s $paraclu_uncut_path and 
			-s $paraclu_cut_path and 
			-s $paraclu_bed_path and 
			-s $paraclu_rev_bed_path and 
			-s $paraclu_fwd_bed_path) {
			
		&reportAndLogStatus("Paraclu results found. Skipping running paraclu", 10, "\n");#->962
			
	} else {

		&reportAndLogStatus("Running paraclu", 10, "\n");#->962
		open PARACLUSH, ">", "$paraclu_sh_path";
		print PARACLUSH "$paraclu_bin $min_paraclu_count <(gzip -dc $paraclu_input_path) | gzip -c >$paraclu_uncut_path\n";
		print PARACLUSH "$cut_sh_path <(gzip -dc $paraclu_uncut_path) | gzip -c >$paraclu_cut_path\n";
		close PARACLUSH;
		system "bash $paraclu_sh_path";

		$globalReadmeHsh_ref->{$paraclu_sh_path}{'description'} = "bash script to run paraclu. Please refer to http://cbrc3.cbrc.jp/~martin/paraclu/";
		$globalReadmeHsh_ref->{$paraclu_uncut_path}{'description'} = "raw paraclu output file, before 'cutting'. Please refer to http://cbrc3.cbrc.jp/~martin/paraclu/";
		$globalReadmeHsh_ref->{$paraclu_cut_path}{'description'} = "paraclu output file, after 'cutting'. Please refer to http://cbrc3.cbrc.jp/~martin/paraclu/";
		$globalReadmeHsh_ref->{$paraclu_bed_path}{'description'} = "bed file (both strand) parsed paraclu output after 'cutting'";
		$globalReadmeHsh_ref->{$paraclu_rev_bed_path}{'description'} = "bed file (only forward strand) parsed paraclu output after 'cutting'";
		$globalReadmeHsh_ref->{$paraclu_fwd_bed_path}{'description'} = "bed file (only reverse strand) parsed paraclu output after 'cutting'";
	
		my $min_non_zero_d = 10000000;
		open PARACLUOUTPUT, "gzip -dc $paraclu_cut_path |";
		while (<PARACLUOUTPUT>) {
			next if $_ =~ m/^#/;
			chomp;
			# sequence, strand, start, end, sites, sum of values, min d, max d
			#chr1	+	24423	248946143	90912	487284	-1e+100	1.49e-05
			my ($chrom, $strand, $start, $end, $sites, $score, $min_d, $max_d) = split /\t/;
			if ($min_non_zero_d > $min_d and $min_d > 0) {
				$min_non_zero_d = $min_d;
			}
		}
		close PARACLUOUTPUT;


		&reportAndLogStatus("Parsing paraclu output", 10, "\n");#->962
		open PARACLUBED, "| sort -k1,1 -k2,2n | gzip -c >$paraclu_bed_path";
		open PARACLUREVBED, "| sort -k1,1 -k2,2n | gzip -c >$paraclu_rev_bed_path";
		open PARACLUFWDBED, "| sort -k1,1 -k2,2n | gzip -c >$paraclu_fwd_bed_path";
		open PARACLUOUTPUT, "gzip -dc $paraclu_cut_path |";
		while (<PARACLUOUTPUT>) {
			next if $_ =~ m/^#/;
			chomp;
			# sequence, strand, start, end, sites, sum of values, min d, max d
			#chr1	+	24423	248946143	90912	487284	-1e+100	1.49e-05
			my ($chrom, $strand, $start, $end, $sites, $score, $min_d, $max_d) = split /\t/;
			my $chromStart = $start - 1;
			my $chromEnd = $end;
			$min_d = $min_non_zero_d if $min_d < $min_non_zero_d;
			my $stability = log($max_d/$min_d)/log(2);
			
			my $ID = join "_", ($chrom, $chromStart, $chromEnd, $strand);
			print PARACLUBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $ID, $stability, $strand)), "\n";
			if ($strand eq '+') {
				print PARACLUFWDBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $ID, $stability, $strand)), "\n";
			} elsif ($strand eq '-') {
				print PARACLUREVBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $ID, $stability, $strand)), "\n";
			} else {
				die "wrong strand\n";
			}
		}
		close PARACLUOUTPUT;
		close PARACLUREVBED;
		close PARACLUFWDBED;
		close PARACLUBED;
	}

	return ($paraclu_bed_path);
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 107
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































